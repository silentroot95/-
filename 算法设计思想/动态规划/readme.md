##### 动态规划

网上搜索动态规划，给的介绍都比较高大上，其实动态规划理解起来并不难。动态规划可以理解为对递归问题的一种改进。任何可以写出递归公式的问题，都可以写出相应的递归算法。对于一些递归算法，计算机在运行时是低效的，我们需要给它提供一些帮助，将递归算法改写成非递归算法，在非递归算法中我们将那些子问题的答案记录在一个表内，利用这种方法的一种技巧就叫做动态规划。

总之，对于一个递归问题采用动态规划优化的套路是：

1. 写出递推公式，递推公式写出来，写出递归算法就不难了，剩下的就是优化了；
2. 采用表记录的递归解法；
3. 非递归的解法（动态规划）。

##### Example 1

第一个例子就是大家耳熟能详的斐波那契数列问题，斐波那契数列的递推公式比较简单：
$$
Fib(n)=Fib(n-1)+Fib(n-2)
$$
对于初始情况$Fib(1)=Fib(2)=1$。

1. 直接递归解法

代码如下：

```c
int Fib(int n)
{
	if(n<=2)
		return 1;
	else
		return Fib(n-1)+Fib(n-2);
}
```

上面的算法非常低效，比如计算$Fib(5)$,写出它的递归树，你就可以看出有些值它计算了很多次，一个比较自然的想法就是使用一个表记录那些已经计算过的值，当计算一个值，先到表中查找它是否已经计算过，如果未计算过，就计算它，并把结果放入表中，这样可以节省大量不必要的计算。

​	2.采用记录表

代码如下：

```c
int book(int *list,int n)
{
    if(list[n] == 0)
        list[n] = book(list,n-1)+book(list,n-2);
    return list[n];
}
int Fib2(int n)
{
    int *list = (int*)calloc(n+1,sizeof(int));
    list[1] = list[2] = 1;
    return book(list,n);
}
```

这段代码中的book函数就是一个记录函数。

​	3.动态规划

上面两个采用的都是递归算法，都是自上向下的计算。动态规划采用非递归解法，是自下向上的计算。

代码如下：

```c
int Fib3(int n)
{
    int prev = 0,curr = 1;
    int ans;
    if(n<=2)
        return 1;
    for(int i=1;i<n;i++)
    {
        ans = prev + curr;
        prev = curr;
        curr = ans;
    }
    return ans;
}
```

这里采用自下向上的计算方法，并把记录表简化为记录前面的两个值，这是计算下一个数所必须的 。