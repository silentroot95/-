#### 最长回文子串

刷leetcode时会遇到这类问题，一般的想法是粗暴地循环，两层循环进行中心扩展搜索，时间复杂度为$O(N^2)$。需要注意的是字符串有两种中心，一种是字符，一种在两个字符之间。由中心向两侧进行比较是否相等。

<img src=".\pic\zx.png" style="zoom:72%;" />

#### 马拉车算法

马拉车算法是计算最长回文子串的一个经典算法，该算法的牛逼之处在于其时间复杂度为O(N)

##### 解决子串长度奇偶问题

在每个字符集间插入‘#’（‘#’不可能出现在字符串中），为了在扩展过程中到边界自动结束，在两端分别插入'^'和'$'，这样中心扩展时，到了边界一定不相等，从而退出循环。经过处理字符串长度一定是奇数。

如`abcdcb`经过扩展变为`^#a#b#c#d#c#b#$`

##### 最长子串长度

我们用一个数组p保存由中心扩展的最大字符个数，它刚好等于去掉'#'的子串的长度。如下图

<img src=".\pic\zc.png" style="zoom:67%;" />

可以看到p[6]=5,它表示以第6个字符为中心的最长子串左右各扩展5个字符，即是`#c#b#c#b#c#`

去掉'#'后，变成`cbcbc`，它的长度刚好是5。

##### 子串的起始字符下标

p的下标i减去p[i]，再整除2，就是子串在原字符串的起始下标。比如上图中最长回文串的长度为5，其中心下标为6，减去p[6]=5，得到1，1再整除2，得到0。

##### p的构建

数组p的生成是该算法的关键。

我们用C表示回文串的中心下标，用R表示其右边界，则R=C+p[i]，我们考虑如何生成p[i]，如下图，用i_mirror表示i关于中心C的镜像下标。

<img src=".\pic\pi.png" style="zoom:67%;" />

求p[i]时我们可以利用对称性，令p[i] = p[i_mirror]，但有一些例外需要考虑

###### 1、超出了R

<img src=".\pic\cs1.png" style="zoom:72%;" />

如上图，此时p[i_mirror]=7，但我们不能令p[i]等于7，因为15+7=22，已经超过右边界20，但此时我们可以扩展到右边界，对于R右边的情况，我们需要比较R+1对应的字符与关于i对称的字符是否相等，像中心扩展一样，一一比较。

###### 2、p[i_mirror]遇到了字符串左边界

<img src=".\pic\yl.png" style="zoom:67%;" />

此时p[i_mirror]等于1是因为它遇到了左边界，而p[i]并未遇到边界，还要在镜像的基础上中心扩展。

###### 3、i等于R

把p[i]赋值为0，然后利用中心扩展

##### C与R的更新

每当求出的p[i]的右边界大于R时，我们就要更新R和C，因为我们要保证i位于最新的回文串中。

<img src=".\pic\cr.png" style="zoom: 67%;" />

如上图i=8,p[i]=5，8+5=13>R，所以R要更新为13，C要更新为8

##### 代码

```python
def preProcess(s):
    '''
    马拉车算法字符串预处理
    '''
    #空字符串处理
    if len(s)==0:
        return '^$'
    t = '#'.join(list(s))
    t = '^#'+t+'#$'
    return t
def Manacher(s):
    '''
    马拉车算法
    '''
    t = preProcess(s)
    length = len(t)
    #数组p
    p = [0]*length
    C=R=0
    for i in range(1,length-1):
        i_mirror = 2*C-i
        #保证i在当前的字串中
        if(R>i):
            #保证不超过右边界
            p[i] = min(R-i,p[i_mirror])
        else:
            #i==R时
            p[i]=0
        #中心扩展
        while(t[i+p[i]+1] == t[i-p[i]-1]):
            p[i] += 1
        #更新C与R
        if(i+p[i]>R):
            C=i
            R=i+p[i]
    #最大回文串长度
    maxlen = max(p)
    #起始索引
    start = (p.index(maxlen)-maxlen) // 2
    return s[start:start+maxlen]
```

时间复杂度O(N)，因为所有的字符最多遍历一次

空间复杂度O(N)。